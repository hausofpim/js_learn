/**
 * Стандартное объявление функции, где standardFunc - имя функции,
 * по которому ее нужно вызвать
 * Принимает в себя два аргумента: arg1 и arg2.
 * Ничего не возвращает
 * @param {any} arg1 - Первый аргумента
 * @param {any} arg2 -Второй аргумент
 */
function standardFunc(arg1, arg2) {
  console.log(arg1, arg2);
}

/* Пример вызова функции standardFunc */
standardFunc("first string", "second string");

/* ---------------------------------------- */

/**
 * Объявление стрелочной функции, где arrowFunction - имя функции,
 * по которому ее нужно вызвать
 * Принимает в себя один аргумент: arg1
 * Возвращает квадрат переданного в аргументе числа
 * @callback sqrtFunction
 * @param {number} arg1 - Число
 * @return {number} квадрат переданного числа
 */
const arrowFunction = (arg1) => {
  return arg1 * arg1;
};

/* 
 Пример вызова функции arrowFunction
 в этом случае результат выполнения нигде не отображается,
 так как фукнция просто возвращает результат (return) 
 */
arrowFunction(12); // 144

/* 
 Пример вызова функции arrowFunction
 в этом случае результат выполнения будет отображен в консоли 
 */
console.log(arrowFunction(11)); // 121

/*
 В яваскрипте функция может принимать сколько угодно аргументов
 какого угодно типа (включая другие функции и даже саму себя) 
*/

/**
 * Функция получает квадрат рандомного числа из диапазона
 * Принимает в себя три аргумента: первые два - минимальное
 * и максмальное число из диапазона. Из этого диапазона будет
 * вычисленно рандомное число. Третий аргумент - функция, которая
 * возводит число в квадрат.
 * Возвращает квадрат рнадомного числа из диапазона
 * @param {number} minNumber - минимальное значение диапазона
 * @param {number} maxNumber - максимальное значение диапазона
 * @param {sqrtFunction} sqrtFunction - функция, которая возводит число в квадрат
 * @return {number} квадрат рандомного числа из диапазона
 */
const randomSqrt = (minNumber, maxNumber, sqrtFunction) => {
  const randomNumber = Math.ceil(
    Math.random() * (maxNumber - minNumber) + minNumber
  ); // Используем Math.ceil() чтобы получить целое число

  return sqrtFunction(randomNumber);
};

/* 
 Пример вызова функции sqrtFunction. Мы передали диапазон от 
 1 до 10 и функцию, которая возводит число в квадрат.
 Важно заметить, что arrowFunction мы здесь не вызываем, 
 а просто передаем ее в фуцнкцию randomSqrt. А уже в randomSqrt
 она вызовется с рандомным числом из диапазона в аргументе. 
*/
console.log(randomSqrt(1, 10, arrowFunction));

/* 
 Так же у каждая функция при вызове содержит в себе 
 локальное окружение (LexicalEnvironment), которое состоит 
 из двух частей: объект с локальными аргументами и 
 переменными/константами и ссылкой на внешнее окружение.
 Все функции работают так, что есть переменная или аргумент по своему
 названию не были найдены внутри функции, то она будет их снаружи
 (по ссылке на внешнее окржение)

 Очень подробно и хорошо это описано здесь: https://learn.javascript.ru/closure
 В этой статье нужно ознакомится с пунктами "https://learn.javascript.ru/closure#bloki-koda" (здесь объясняют смысл фигурных скобок в JS, важно заметить что у if, циклов и любого кода, обернутого в {} свое окружение перменных и аргументов, которое так же содержит ссылку на внешнее окружение), "https://learn.javascript.ru/closure#vlozhennye-funktsii" и "https://learn.javascript.ru/closure#leksicheskoe-okruzhenie"

 Примеры кода лучше рассмотреть в статье, можно переписать в своЙ файл
 и поэкспериментировать для лучшего понимая происходящего.
*/

/* 
 Один из примеров замыкания, функция sayMyName. Здесь нет никакой ошибки,
 так как, если функция не найдет переменную/аргумент внутри себя, то будет
 искать снаружи (по ссылке на внешнее окружение)
*/
const name = "Danil";
const sayMyName = () => {
  console.log(`Меня зовут ${name}`);
};
sayMyName();

/* 
 А вот здесь переменная name из 99 строки уже не будет использована,
 так как внутри sayMyName2 уже существует переменная name со своим значением
 'Evgen' 
*/
const sayMyName2 = () => {
  const name = "Evgen";
  console.log(`Меня зовут ${name}`);
};
sayMyName2();

/* 
 Кстати, если в стрелочных функциях выполняется всего одно действие, то 
 ее можно записать следующим образом:

 То есть мы убираем фигурные скобки и пишем единственное действие функции
 в одну строку вместе с объявлением. Важно заметить! Что это единственное
 действие будет возвращено как результат выполнения функции!
*/
const sayMyNameShorted = () => console.log(`Меня зовут ${name}`);
sayMyNameShorted();

/* 
 Одна из нераспространенных практик, это стандартное объявление функции
 с сохранением ее в переменную, как в примере ниже. 

 Так делать можно, но не рекомендуется, так как для сохранения функции
 в переменную, правильной записью считается стрелочная функция
*/
const standardFuncInConst = function (a, b) {
  console.log(a + b);
};

/* 
 Функция так же может быть АНОНИМНОЙ, то есть у нее не будет имени.
 Для примера возьмем функцию randomSqrt, о которой говорилось выше.
 Первые два аргумента это числа, а третий - функция. В примере выше
 мы третьим аргументом передвали константу, в которой была готова функция.
 Но мы сразу можем передать в третьи аргумент randomSqrt функцию. Например:
*/
randomSqrt(1, 10, (number) => number * number);

/* 
 То есть мы передали 1 и 10 - диапазон рандомных чисел. А в третьем 
 аргументе у нас стрелочная функция, которая принимает в себя number
 и умножает это число само на себя (возводит в квадрат). Заметь, что 
 переданная стрелочная функция выполняет всего одно действие, и сразу же
 возвращает его. Можно представить, что перед number * number написан return,
 то есть по другому эту функцию можно было бы написать вот так:
 
  randomSqrt(1, 10, (number) => {
    return number * number;
  });

 Ну и стоит сказать, что переданная в третьем аргументе функция, которая 
 возводит число в квадрат, является анонимной, так как мы нигде не 
 обозначаем ее имя. 
*/

/* 
 Ниже так же один из примеров передачи анонимной функции как аргумента.
 Встроенная в JS функция setTimeout принимает в себя два аргумента:
 первый - функция, которая будет выполнена после истечении времени в 
 миллисекундах, а второй аргумент - как раз кол-во миллисекунд, через 
 которое должна сработать функция, переданная в первом аргументе.

 То есть здесь, через 1000 миллисекунд из второго аргумента (1 секунда),
 будет выполнена функция, которая пишет в консоль лог 'Таймер сработал!'.
 Функция, переданная в первом аргументе так же является анонимной.
*/
setTimeout(() => {
  console.log("Таймер сработал!");
}, 1000);

/* 
 Так как функция в первом аргументе выполняет только одно действие - 
 выводит надпись в консоль лог, то ее можно записать следующим образом:
*/
setTimeout(() => console.log("Второй таймер сработал!"), 2000);

/* 
 Важно заметить! в случае с первым таймером, функция ничего не возвращает,
 так как у нее есть фигурные скобки и нет возвращающего слова return

 А второй таймер возвращает результат выполнения своего единственного 
 действия, так как у него нет фигурных скобок и нет слова return. 

 Важно запомнить! Если функция записана как в примере со вторым таймером,
 то она ВСЕГДА выполняет результат выполнения. 
 Подробнее в примере с randomSqrt()
*/

/* 
 Ниже пример РЕКУРСИВНОЙ функции, то есть функции, которая вызывает саму себя.
 Для теории: когда функция вызывает саму себя, это назвается РЕКУРСИЕЙ,
 следовательно сама функция в этом случае называется РЕКУРСИВНОЙ.

 Функция находит факториал от полученного числа, например факториал от 5 -
 это 5!, то есть 1 * 2 * 3 * 4 * 5 = 120. Только в примере ниже, умножение идет
 с обратной стороны: 5 * 4 * 3 * 2 * 1. То есть когда мы вызываем функцию на
 214 строке с арументом 5, то функция сначала проверяет: number меньше или
 равен одному? Нет, поэтому будет выполнено number * numFactorial(number - 1),
 то есть 5 * numFactorial(4), а там снова проверка на меньше или равно и далее
 4 * numFactorial(3) и такая цепочка будет продолжаться пока не будет вызван 
 2 * numFactorial(1) - в этот момент функция не будет вызывать саму себя, а просто вернет единицу (так как 1 * 1 это 1). То есть рекурсия обязательно
 должна в один момент остановится. В любой рекурсивной функции должно быть
 условие, при котором функция не будет вызывать саму себя. Когда код приходит
 в это условие (в нашем примере это if (number <= 1)), то рекурсия 
 заканчивается и будет возвращен результат всех выполнений рекурсии. 
*/
const numFactorial = (number) => {
  if (number <= 1) {
    return 1;
  }

  return number * numFactorial(number - 1);
};

console.log(numFactorial(5));
